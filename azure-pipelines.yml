# =========================================
# TRIGGER: Quando o pipeline ser√° executado
# =========================================
# Executa automaticamente quando houver push na branch main
trigger:
  - main

# ============================================================================
# VARI√ÅVEIS GLOBAIS DO PIPELINE
# ============================================================================
variables:
  GRADLE_USER_HOME: $(Pipeline.Workspace)/.gradle 
  AZURE_LOCATION: eastus 
  AZURE_SUBSCRIPTION_ID: 0d4c88e7-0651-4c08-98ee-91f417a4f71c 
  RESOURCE_GROUP: rg-nextjob 
  ACR_NAME: acrnextjob 
  ACR_LOGIN_SERVER: acrnextjob.azurecr.io 
  IMAGE_NAME: appnextjob  
  IMAGE_TAG: latest   
  RM: "555197"  
  azureSubscription: AzureNextJob                      
  DB_NAME: nextjob                               
  DB_USER: nextjob    

# ============================================
# BUILD (CI - Integra√ß√£o Cont√≠nua)
# ============================================
# Compila o c√≥digo Java, executa testes e cria a imagem Docker
stages:
  - stage: Build
    displayName: CI (build & tests)
    jobs:
      # ===========================================
      # JOB 1.1: BUILD DA APLICA√á√ÉO JAVA COM GRADLE
      # ===========================================
      - job: gradleBuild
        pool:
          vmImage: ubuntu-latest 

        steps:
          # --------------------------------------
          # STEP 1.1.1: CONFIGURAR CACHE DO GRADLE
          # --------------------------------------
          # Cache: guarda depend√™ncias baixadas para acelerar builds futuros
          - task: Cache@2
            inputs:
              key: 'gradle | "$(Agent.OS)" | **/*.gradle*'
              restoreKeys: |
                gradle | "$(Agent.OS)"
                gradle
              path: $(GRADLE_USER_HOME)
            displayName: Configure gradle caching

          # -------------------------------------
          # STEP 1.1.2: EXECUTAR BUILD COM GRADLE
          # -------------------------------------
          # Compila o c√≥digo Java, gera o arquivo JAR da aplica√ß√£o
          - task: Gradle@4
            inputs:
              gradleWrapperFile: "gradlew"                         
              tasks: "build"                                    
              options: "--build-cache -Dspring.profiles.active=dev -x test" 
              publishJUnitResults: false             
              javaHomeOption: "JDKVersion"
              jdkVersionOption: "1.21"               
              sonarQubeRunAnalysis: false  

          # -----------------------------------
          # STEP 1.1.3: PARAR DAEMON DO GRADLE
          # -----------------------------------
          # Libera recursos da m√°quina virtual
          - script: ./gradlew --stop
            displayName: Gradlew stop

          # ----------------------------------------------------------------------
          # STEP 1.1.4: COPIAR ARQUIVOS PARA √ÅREA DE ARTEFATOS
          # ----------------------------------------------------------------------
          # Copia o JAR gerado, e permite que outros jobs acessem o arquivo
          - task: CopyFiles@2
            displayName: "Copy Files to artifact staging directory"
            inputs:
              SourceFolder: "$(System.DefaultWorkingDirectory)"
              Contents: "**/build/libs/*SNAPSHOT.jar" 
              TargetFolder: $(Build.ArtifactStagingDirectory)

          # ----------------------------------------------------------------------
          # STEP 1.1.5: PUBLICAR ARTEFATO
          # ----------------------------------------------------------------------
          # Disponibiliza o JAR para download e para pr√≥ximos jobs
          - publish: $(Build.ArtifactStagingDirectory)
            artifact: nextjobApp

      # ========================================================================
      # JOB 1.2: BUILD DA IMAGEM DOCKER E PUSH PARA ACR
      # ========================================================================
      - job: BuildAndPushImage
        displayName: Build and push docker image
        pool:
          vmImage: ubuntu-latest
        dependsOn: gradleBuild
        condition: succeeded() 
        steps:
          - task: AzureCLI@2
            displayName: 'Build and Push Docker Image'
            inputs:
              azureSubscription: '$(azureSubscription)' 
              scriptType: bash
              scriptLocation: inlineScript
              addSpnToEnvironment: true
              inlineScript: |
                # Aborta script se qualquer comando falhar
                set -euo pipefail
                
                # ----------------------------------------------------------
                # STEP 1.2.1: LOGIN NO AZURE CONTAINER REGISTRY
                # ----------------------------------------------------------
                # Autentica o Docker para permitir push de imagens
                echo "Logging into ACR..."
                
                # Verifica se tem acesso ao ACR
                echo "Checking ACR access..."
                ACR_CHECK=$(az acr list --query "[?name=='$(ACR_NAME)'].name" -o tsv 2>/dev/null || echo "")
                
                if [ -z "$ACR_CHECK" ]; then
                  echo "‚ö†Ô∏è  WARNING: Cannot access ACR $(ACR_NAME)"
                  echo "Service Principal may need 'AcrPush' role"
                  echo "Attempting login anyway..."
                fi
                
                az acr login --name $(ACR_NAME) || {
                  echo "‚ùå ERROR: Failed to login to ACR"
                  echo "Please ensure the Service Principal has 'AcrPush' role on $(ACR_NAME)"
                  exit 1
                }
                
                # ----------------------------------------------------------
                # STEP 1.2.2: BUILD DA IMAGEM DOCKER
                # ----------------------------------------------------------
                # Cria a imagem Docker a partir do Dockerfile
                echo "Building Docker image..."
                docker build -t $(ACR_LOGIN_SERVER)/$(IMAGE_NAME):$(IMAGE_TAG) \
                            -t $(ACR_LOGIN_SERVER)/$(IMAGE_NAME):$(Build.BuildId) \
                            -f Dockerfile .
                
                # ----------------------------------------------------------
                # STEP 1.2.3: PUSH DAS IMAGENS PARA O ACR
                # ----------------------------------------------------------
                # Envia as imagens para o reposit√≥rio privado no Azure
                echo "Pushing images to ACR..."
                docker push $(ACR_LOGIN_SERVER)/$(IMAGE_NAME):$(IMAGE_TAG)
                docker push $(ACR_LOGIN_SERVER)/$(IMAGE_NAME):$(Build.BuildId)
                
                echo "‚úÖ Images pushed successfully!"

  # ==============
  #  DEPLOY CD
  # ==============
  # Faz o deploy da aplica√ß√£o no Azure Container Instances
  - stage: Deploy_ACI
    displayName: CD - Deploy to Azure Container Instances
    dependsOn: Build
    condition: succeeded() 
    jobs:
      - job: Deploy
        displayName: Deploy App to ACI
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: none 

          - task: AzureCLI@2
            displayName: 'Deploy Application to ACI'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: bash
              scriptLocation: inlineScript
              addSpnToEnvironment: true
              inlineScript: |
                # Aborta script se qualquer comando falhar
                set -euo pipefail

                # ----------------------------------------------------------
                # STEP 2.1: VERIFICAR E CONFIGURAR SUBSCRIPTION
                # ----------------------------------------------------------
                # Lista todas as subscriptions dispon√≠veis
                echo "Available subscriptions:"
                az account list --output table
                
                # Verifica se tem acesso √† subscription
                echo "Checking subscription access..."
                SUBSCRIPTION_CHECK=$(az account list --query "[?id=='$(AZURE_SUBSCRIPTION_ID)'].id" -o tsv)
                
                if [ -z "$SUBSCRIPTION_CHECK" ]; then
                  echo "‚ö†Ô∏è  WARNING: Service Principal does not have access to subscription $(AZURE_SUBSCRIPTION_ID)"
                  echo "Attempting to use default subscription..."
                  # Tenta usar a subscription padr√£o dispon√≠vel
                  FALLBACK_SUB=$(az account list --query "[0].id" -o tsv)
                  if [ -n "$FALLBACK_SUB" ]; then
                    echo "Using fallback subscription: $FALLBACK_SUB"
                    az account set --subscription "$FALLBACK_SUB"
                  else
                    echo "‚ùå ERROR: No subscriptions available"
                    echo "Please grant the Service Principal 'Contributor' role on subscription $(AZURE_SUBSCRIPTION_ID)"
                    echo "Run: az role assignment create --assignee <service-principal-id> --role Contributor --scope /subscriptions/$(AZURE_SUBSCRIPTION_ID)"
                    exit 1
                  fi
                else
                  # Define qual subscription usar
                  echo "Setting Azure subscription..."
                  az account set --subscription "$(AZURE_SUBSCRIPTION_ID)"
                fi
                
                # Mostra subscription ativa
                echo "Active subscription:"
                az account show

                echo "Using resource group: $(RESOURCE_GROUP) in $(AZURE_LOCATION)"

                # ----------------------------------------------------------
                # STEP 2.2: OBTER CREDENCIAIS DO ACR
                # ----------------------------------------------------------
                # Recupera usu√°rio e senha para autenticar no ACR
                # Necess√°rio para o ACI puxar a imagem Docker
                echo "Getting ACR credentials..."
                ACR_USERNAME=$(az acr credential show --name "$(ACR_NAME)" --query username -o tsv)
                ACR_PASSWORD=$(az acr credential show --name "$(ACR_NAME)" --query "passwords[0].value" -o tsv)
                
                # Valida se conseguiu as credenciais
                if [ -z "$ACR_USERNAME" ] || [ -z "$ACR_PASSWORD" ]; then
                  echo "ERROR: Failed to get ACR credentials"
                  exit 1
                fi
                
                echo "ACR Username: $ACR_USERNAME"

                # ----------------------------------------------------------
                # STEP 2.3: DEFINIR NOMES DO CONTAINER E DNS
                # ----------------------------------------------------------
                # DNS Label: cria URL p√∫blica √∫nica para acessar aplica√ß√£o
                # Formato: aci-app-nextjob-rm555197.eastus.azurecontainer.io
                APP_CONTAINER_NAME="aci-app-nextjob-rm$(RM)"
                APP_DNS_LABEL="aci-app-nextjob-rm$(RM)"

                # ----------------------------------------------------------
                # STEP 2.4: LIMPAR CONTAINER ANTERIOR
                # ----------------------------------------------------------
                # Remove container antigo para liberar DNS e evitar conflitos
                # || true: ignora erro se n√£o existir
                echo "Cleaning up previous container if it exists..."
                az container delete --resource-group "$(RESOURCE_GROUP)" --name "$APP_CONTAINER_NAME" --yes 2>/dev/null || true
                sleep 15

                # ----------------------------------------------------------
                # STEP 2.5: CRIAR E DEPLOY DO CONTAINER DA APLICA√á√ÉO
                # ----------------------------------------------------------
                APP_IMAGE="$(ACR_LOGIN_SERVER)/$(IMAGE_NAME):$(IMAGE_TAG)"
                echo "Deploying application container: $APP_CONTAINER_NAME"
                echo "Using image: $APP_IMAGE"

                # Azure Container Instances: executa containers sem gerenciar VMs
                az container create \
                  --resource-group "$(RESOURCE_GROUP)" \
                  --name "$APP_CONTAINER_NAME" \
                  --image "$APP_IMAGE" \
                  --cpu 1 --memory 1.5 \                              # Recursos: 1 CPU, 1.5GB RAM
                  --registry-login-server "$(ACR_LOGIN_SERVER)" \     # URL do ACR
                  --registry-username "$ACR_USERNAME" \               # Usu√°rio ACR
                  --registry-password "$ACR_PASSWORD" \               # Senha ACR
                  --environment-variables \                           # Vari√°veis de ambiente p√∫blicas
                    SPRING_DATASOURCE_URL="$(SPRING_DATASOURCE_URL)" \           # URL do banco
                    SPRING_DATASOURCE_USERNAME="$(SPRING_DATASOURCE_USERNAME)" \ # Usu√°rio DB
                    SPRING_JPA_HIBERNATE_DDL_AUTO=validate \          # Hibernate: validar schema
                    SPRING_FLYWAY_ENABLED=true \                      # Flyway: migrations
                    SPRING_FLYWAY_BASELINE_ON_MIGRATE=true \          # Flyway: baseline
                    GROQ_API_KEY="$(GROQ_API_KEY)" \                 # API Key da IA Groq
                    GROQ_API_URL="https://api.groq.com/openai/v1/chat/completions" \  # URL API
                    GROQ_MODEL="llama-3.3-70b-versatile" \           # Modelo de IA
                    GITHUB_CLIENT_ID="$(GITHUB_CLIENT_ID)" \         # OAuth GitHub
                    GITHUB_CLIENT_SECRET="$(GITHUB_CLIENT_SECRET)" \ # OAuth GitHub
                  --secure-environment-variables \                    # Vari√°veis seguras (criptografadas)
                    SPRING_DATASOURCE_PASSWORD="$(SPRING_DATASOURCE_PASSWORD)" \  # Senha DB
                  --ports 8080 \                                      # Porta da aplica√ß√£o
                  --ip-address Public \                               # IP p√∫blico
                  --os-type Linux \                                   # Sistema operacional
                  --dns-name-label "$APP_DNS_LABEL" \                # Nome DNS
                  --location "$(AZURE_LOCATION)" \                    # Regi√£o Azure
                  --restart-policy Always                             # Reiniciar sempre

                # ----------------------------------------------------------
                # STEP 2.6: VERIFICAR STATUS E EXIBIR URL
                # ----------------------------------------------------------
                if [ $? -eq 0 ]; then
                  echo "Waiting for container to start..."
                  sleep 20
                  
                  # Verifica estado do container
                  CONTAINER_STATE=$(az container show \
                    --resource-group "$(RESOURCE_GROUP)" \
                    --name "$APP_CONTAINER_NAME" \
                    --query "containers[0].instanceView.currentState.state" \
                    -o tsv)
                  
                  echo "Container state: $CONTAINER_STATE"
                  
                  # Obt√©m URL p√∫blica (FQDN: Fully Qualified Domain Name)
                  APP_FQDN=$(az container show \
                    --resource-group "$(RESOURCE_GROUP)" \
                    --name "$APP_CONTAINER_NAME" \
                    --query ipAddress.fqdn \
                    -o tsv)
                  
                  APP_URL="http://${APP_FQDN}:8080"
                  echo ""
                  echo "‚úÖ ============================================"
                  echo "‚úÖ Application deployed successfully!"
                  echo "=============================================="
                  echo "üåê Application URL: $APP_URL"
                  echo "üîç Health Check: $APP_URL/actuator/health"
                  echo ""
                else
                  echo "‚ùå Failed to deploy container"
                  exit 1
                fi